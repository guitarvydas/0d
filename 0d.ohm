Basic {
  main = "don't care, this must be redefined"
}

BasicComment <: Basic {
  comment =  "/*" commentInnards* "*/"
  commentInnards =
    | "/*" commentInnards* "*/" -- rec
    | ~"/*" ~"*/" any -- flat

  space += comment
}

BasicString <: BasicComment {
  string = sq (~sq any)* sq
  sq = "'"
}

BasicKeywordPrefix <: BasicString {
  kp = "#"
}

BasicPrefix <: BasicKeywordPrefix {
  lambdaPrefix = "Œª"
  procedurePrefix = "≈æ"
  statePrefix = "‚ú¶"
  parameterPrefix = "ùúå"
}

BasicUnaryOperator <: BasicPrefix {
  new = "‚Üµ"
  call = "/"
  self = "≈°"
  phi = "œï"
  temp = "ùúè"
  forAll = "‚àÄ"
  query = "#?" 
  defineop = "‚â£"

  unaryOperator = new | call | self | phi | temp | forAll | query | defineop | kp
}

BasicBinaryOperator <: BasicUnaryOperator {
  dot = "."
  updateState = "‚áí"
  binaryOperator = dot | updateState
}

BasicBrackets <: BasicBinaryOperator {
  messageBegin = "‚ü™"
  messageEnd = "‚ü´"
  verbatimBegin = "¬´"
  verbatimEnd = "¬ª"
  compoundNameBegin = "‚ù≤"
  compoundNameEnd = "‚ù≥"
  dtypeBegin = "‚ü®"
  dtypeEnd = "‚ü©"
  tagBegin = "‚ü®#"
  tagEnd = "‚ü©"

  nameBracket = compoundNameBegin | compoundNameEnd
  dtypeBracket = dtypeBegin | dtypeEnd
  messageBracket = messageBegin | messageEnd
  verbatimBracket = verbatimBegin | verbatimEnd
  tagBracket = tagBegin | tagEnd
  
  bracket =
    | "(" | ")" | "{" | "}" | "[" | "]" | "<" | ">"
    | nameBracket | dtypeBracket | messageBracket | verbatimBracket | tagBracket

}

BasicDelimiter <: BasicBrackets {
  delimiter = bracket | unaryOperator | kp
}

BasicKeywords <: BasicDelimiter {
  // keyword prefix - strictly not necessary, but helps with visual inspection during bootstrap
  
  yes = kp "yes"
  no = kp "no"
  def = kp "def"
  inner = kp "inner"
  synonym = kp "synonym"

  keyword = yes | no | def | inner
}

BasicGrammar <: BasicKeywords {
}



ZeroD <: BasicGrammar {
  main := definition+

  Definition = DtypeDefinition | TagDefinition | FunctionDefinition | ProcedureDefinition
    | ConstructorDefinition | Immediate
  definition = applySyntactic<Definition>
  Immediate = Expression
    
  FunctionDefinition = def "function" name FormalParameterList? Block
  ProcedureDefinition = def "procedure" name FormalParameterList? Block
  InnerFunctionDefinition = inner "function" name FormalParameterList? Block
  InnerProcedureDefinition = inner "procedure" name FormalParameterList? Block
  ConstructorDefinition = def "constructor" name FormalParameterList? PossibleStates ConstructorBlock

  ConstructionExpression = ConstructorFieldAssign | Expression

  ConstructorFieldAssign = selfFieldName defineop Expression

  Expression =
    | ForallExpression
    | StateUpdateExpression
    | StateQueryExpression
    | DtypeQueryExpression
    | TagQueryExpression
    | InnerFunctionDefinition
    | InnerProcedureDefinition
    | verbatim
    | primary

primary =
  | applySyntactic<SelfMethodCall> -- methodCallOfSelf
  | applySyntactic<MethodCall> -- methodCallOfPrimary
  | applySyntactic<BuiltinCall> -- builtinCall
  | selfFieldName -- fieldOfSelf
  | primary dot name -- fieldOfPrimary
  | temporaryName -- temp
  | lambdaPrefix name -- function
  | procedurePrefix name -- procedure
  | parameterPrefix name -- parameter
  | stateName -- state
  | applySyntactic<Instantiation>
  | phi -- null
  | applySyntactic<MessageWithDebug> -- messageWithDebugInfo
  | applySyntactic<MessageWithoutDebug> -- messageWithoutDebugInfo
  | applySyntactic<DtypeValue> -- dtype
  | applySyntactic<TagValue> -- tag
  | applySyntactic<DtypeList> -- dtypeList
  | applySyntactic<TagList> -- tagList
  | applySyntactic<GenericList> -- genericList
  | string -- string
  | applySyntactic<SynonymScopedBlock>
  | self -- self
  | name -- name

selfFieldName = self dot name
temporaryName = temp name 
stateName = statePrefix name
SelfMethodCall = self call name ActualParameterList?
MethodCall = primary call name ActualParameterList?
BuiltinCall = kp call name ActualParameterList?
Instantiation = new primary ActualParameterList?
MessageWithDebug = messageBegin primary primary primary primary
MessageWithoutDebug = messageBegin primary primary



//Verbatim {
  verbatim = verbatimBegin verbatimInnards+ verbatimEnd
  verbatimInnards =
    | verbatimBegin expr verbatimEnd -- switchGrammars
    | ~verbatimBegin ~verbatimEnd any -- flat
  expr = applySyntactic<Expression>
//}



//Tag {
  TagName = "‚ü®#" name "‚ü©"
  TagDefinition = def "tag" "‚ü®#" name name+ "‚ü©"
  TagValue = 
    | "‚ü®#" name Expression+ "‚ü©"
//}

//Dtype {
  DtypeName = "‚ü®" name "‚ü©"
  DtypeDefinition =
    | def "dtype" name "=" CompoundDtype+ ("|" "*")? -- compound
    | def "dtype" "‚ü®" name name+ "‚ü©" -- single
  DtypeValue =
    | "‚ü®" name Expression+ "‚ü©"

  CompoundDtype = DtypeName | TagName
//}

//List {
  listEnd = "]"
  genericListBegin = "["
  DtypeList = genericListBegin DtypeName Expression* listEnd
  TagList = genericListBegin TagName Expression* listEnd
  GenericList = genericListBegin "*" Expression* listEnd
//}

//Name {
  name =
    | compoundName -- compoundName
    | self -- self
    | phi -- null
    | basicName -- basicName

  compoundName = "‚ù≤" (~nameBracket any)* "‚ù≥"
  basicName = nameFirst nameRest*
  nonSpecialName = ~self ~keyword name
  
  nameFirst = letter | "_"
  nameRest = alnum | "_"

//}

//Operator {
  StateQueryExpression = query self "{" StateQueryClause+ "}"
  DtypeQueryExpression = query DtypeName "{" DtypeQueryClause+ "}"
  TagQueryExpression = query TagName "{" TagQueryClause+ "}"
  ForallExpression = forAll Expression temporaryName Block

StateQueryClause = query self stateName "{" Expression Expression "}"
DtypeQueryClause = query DtypeName DtypeValue "{" Expression Expression "}"
TagQueryClause = query TagName TagValue "{" Expression Expression "}"

  StateUpdateExpression = Expression updateState self 
//}

//ParameterList {
  FormalParameterList = "(" pname* ")"
  ActualParameterList = "(" Expression* ")"
  pname = parameterPrefix name
//}

// StateList {
  PossibleStates = "{" sname+ "}"
  sname = statePrefix name
//}

//Block {
  Block = "{" Expression* "}"
  ConstructorBlock = "{" ConstructionExpression* "}"
//}

//Synonym {
  SynonymScopedBlock = synonym name defineop Expression Block
//}
  

}
