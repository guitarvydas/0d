Forward {
  // these must be redefined (":=") in the final grammar
  main = "forward"
  Expression = "forward"
  name = "forward
}

BasicComment {
  comment =  "/*" commentInnards* "*/"
  commentInnards =
    | "/*" commentInnards* "*/" -- rec
    | ~"/*" ~"*/" any -- flat

  space += comment
}

oBasicVerbatim {
  verbatim = verbatimBegin verbatimInnards+ verbatimEnd
  verbatimInnards =
    | verbatimBegin expr verbatimEnd -- switchGrammars
    | ~verbatimBegin ~verbatimEnd any -- flat
  expr = applySyntactic<Expression>
}

BasicCodeSnippets {
  snippetPrefix = "##"
}

BasicString {
  string = sq (~sq any)* sq
  sq = "'"
}

BasicKeywordPrefix {
  kp = "#"
}

BasicPrefixes {
  lambdaPrefix = "λ"
  procedurePrefix = "ž"
  statePrefix = "✦"
  parameterPrefix = "𝜌"
}

BasicUnaryOperators {
  new = "↵"
  call = "/"
  self = "š"
  phi = "ϕ"
  temp = "𝜏"
  forAll = "∀"
  query = "#?" 
  defineop = "≣"
}

BasicBinaryOperator {
  dot = "."
}

BasicBrackets {
  messageBegin = "⟪"
  messageEnd = "⟫"
  verbatimBegin = "«"
  verbatimEnd = "»"
  compoundNameBegin = "❲"
  compoundNameEnd = "❳"
  dtypeBegin = "⟨"
  dtypeEnd = "⟩"
  tagBegin = "⟨#"
  tagEnd = "⟩"

  nameBracket = compoundNameBegin | compoundNameEnd
  dtypeBracket = dtypeBegin | dtypeEnd
  messageBracket = messageBegin | messageEnd
  verbatimBracket = verbatimBegin | verbatimEnd
  tagBracket = tagBegin | tagEnd
  
  bracket =
    | "(" | ")" | "{" | "}" | "[" | "]" | "<" | ">"
    | nameBracket | dtypeBracket | messageBracket | verbatimBracket | tagBracket

}

BasicDelimiter {
  delimiter = bracket | unaryOperator | kp
}

BasicKeywords <: BasicKeywordPrefix {
  // keyword prefix - strictly not necessary, but helps with visual inspection during bootstrap
  
  yes = kp "yes"
  no = kp "no"
  def = kp "def"
  synonym = kp "synonym"

  keyword = yes | no | def
}

BasicTag {
  tagName = "⟨#" name "⟩"
  tagDefinition = "⟨#" name name+ "⟩"
  tag = 
    | "⟨#" name Expression "⟩"
    | "⟨#" name name "⟩"
}

BasicDtype {
  dtypeName = "⟨" name "⟩"
  dtypeDefinition = "⟨#" name name+ "⟩"
  dtype =
    | "⟨#" name Expression "⟩"
    | "⟨#" name name "⟩"
}

BasicList {
  listEnd = "]"
  dtypeListBegin = "[⟨"
  tagListBegin = "[⟨#"
  genericListBegin = "["
  dtypeList = dtypeListBegin Expression* listEnd
  tagList = tagListBegin Expression* listEnd
  genericList = genericListBegin Expression* listEnd
}


Name {
  name =
    | compoundName -- compoundName
    | self -- self
    | phi -- null
    | basicName -- basicName

  compoundName = "❲" (~nameBracket any)* "❳"
  basicName = nameFirst nameRest*
  nonSpecialName = ~self ~keyword name
  
  nameFirst = letter | "_"
  nameRest = alnum | "_"

}

Operator {
  queryState = query state
  queryDtype = query dtypeName
  queryTag = query tagName
  forall = forAll
  unaryOperator = new | lambda | proc | call | state | self | phi | temp  | parameter
    | forAll
    | kp
  binaryOperator = dot
}

ParameterList <: Forward {
  FormalParameterList = "(" pname* ")"
  ActualParameterList = "(" Expression* ")"
  pname = parameterPrefix name
}

StateList <: Forward {
  PossibleStates = "{" sname+ "}"
  sname = statePrefix name
}

Block {
  Block = "{" Expression* "}"
}

Synonym {
  SynonymScopedBlock = synonym name defineop Block
}
  

GrammarBackbone <: ??? {
}

ZeroD <: GrammarBackBone {
  main := definition+

  Definition = dtypeDefinition | tagDefinition | functionDefinition | procedureDefinition
    | ConstructorDefinition
    
  functionDefinition = def "function" FormalParameters Block
  procedureDefinition = def "procedure" FormalParameters Block
  ConstructorDefinition = def "constructor" FormalParameters PossibleStates Block

  ConstructionExpression = ConstructorFieldAssign | Expression

  ConstructorFieldAssign = selfFieldName defineop Expression

  Expression =
    | forallExpression
    | stateUpdateExpression
    | stateQueryExpression
    | dtypeQueryExpression
    | tagQueryExpression
    | verbatim
    | primary

primary = 
  | self call name -- methodCallOfSelf
  | primary call name -- methodCallOfPrimary
  | self (dot name)? -- fieldOfSelf
  | primary (dot name)? -- fieldOfPrimary
  | temporary name -- temp
  | lambdaPrefix name -- function
  | procedurePrefix name -- procedure
  | parameterPrefix name -- parameter
  | statePrefix name -- state
  | new primary -- instantiation
  | phi -- null
  | messageBegin primary primary primary primary -- messageWithDebugInfo
  | messageBegin primary primary -- messageWithoutDebugInfo
  | dtype -- dtype
  | tag -- tag
  | dtypeList -- dtypeList
  | tagList -- tagList
  | genericList -- genericList
}
