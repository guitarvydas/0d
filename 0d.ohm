Basic {
  main = "don't care, this must be redefined"
}

BasicComment <: Basic {
  comment =  "/*" commentInnards* "*/"
  commentInnards =
    | "/*" commentInnards* "*/" -- rec
    | ~"/*" ~"*/" any -- flat

  space += comment
}

BasicString <: BasicComment {
  string = sq (~sq any)* sq
  sq = "'"
}

BasicKeywordPrefix <: BasicString {
  kp = "#"
}

BasicPrefix <: BasicKeywordPrefix {
  lambdaPrefix = "Œª"
  procedurePrefix = "≈æ"
  statePrefix = "‚ú¶"
  parameterPrefix = "ùúå"
}

BasicUnaryOperator <: BasicPrefix {
  new = "‚Üµ"
  call = "/"
  self = "≈°"
  phi = "œï"
  temp = "ùúè"
  forAll = "‚àÄ"
  query = "#?" 
  defineop = "‚â£"

  unaryOperator = new | call | self | phi | temp | forAll | query | defineop | kp
}

BasicBinaryOperator <: BasicUnaryOperator {
  dot = "."
  updateState = "‚áí"
  binaryOperator = dot | updateState
}

BasicBrackets <: BasicBinaryOperator {
  messageBegin = "‚ü™"
  messageEnd = "‚ü´"
  verbatimBegin = "¬´"
  verbatimEnd = "¬ª"
  compoundNameBegin = "‚ù≤"
  compoundNameEnd = "‚ù≥"
  dtypeBegin = "‚ü®"
  dtypeEnd = "‚ü©"
  tagBegin = "‚ü®#"
  tagEnd = "‚ü©"

  nameBracket = compoundNameBegin | compoundNameEnd
  dtypeBracket = dtypeBegin | dtypeEnd
  messageBracket = messageBegin | messageEnd
  verbatimBracket = verbatimBegin | verbatimEnd
  tagBracket = tagBegin | tagEnd
  
  bracket =
    | "(" | ")" | "{" | "}" | "[" | "]" | "<" | ">"
    | nameBracket | dtypeBracket | messageBracket | verbatimBracket | tagBracket

}

BasicDelimiter <: BasicBrackets {
  delimiter = bracket | unaryOperator | kp
}

BasicKeywords <: BasicDelimiter {
  // keyword prefix - strictly not necessary, but helps with visual inspection during bootstrap
  
  yes = kp "yes"
  no = kp "no"
  def = kp "def"
  synonym = kp "synonym"

  keyword = yes | no | def
}

BasicGrammar <: BasicKeywords {
}



ZeroD <: BasicGrammar {
  main := definition+

  Definition = DtypeDefinition | TagDefinition | FunctionDefinition | ProcedureDefinition
    | ConstructorDefinition
  definition = applySyntactic<Definition>
    
  FunctionDefinition = def "function" FormalParameterList Block
  ProcedureDefinition = def "procedure" FormalParameterList Block
  ConstructorDefinition = def "constructor" FormalParameterList PossibleStates Block

  ConstructionExpression = ConstructorFieldAssign | Expression

  ConstructorFieldAssign = selfFieldName defineop Expression

  Expression =
    | ForallExpression
    | StateUpdateExpression
    | StateQueryExpression
    | DtypeQueryExpression
    | TagQueryExpression
    | verbatim
    | primary

primary = 
  | self call name -- methodCallOfSelf
  | primary call name -- methodCallOfPrimary
  | selfFieldName -- fieldOfSelf
  | self -- self
  | primary dot name -- fieldOfPrimary
  | temporaryName -- temp
  | lambdaPrefix name -- function
  | procedurePrefix name -- procedure
  | parameterPrefix name -- parameter
  | statePrefix name -- state
  | new primary -- instantiation
  | phi -- null
  | messageBegin primary primary primary primary -- messageWithDebugInfo
  | messageBegin primary primary -- messageWithoutDebugInfo
  | applySyntactic<Dtype> -- dtype
  | applySyntactic<Tag> -- tag
  | applySyntactic<DtypeList> -- dtypeList
  | applySyntactic<TagList> -- tagList
  | applySyntactic<GenericList> -- genericList
  | name -- name

selfFieldName = self dot name
temporaryName = temp name 



//Verbatim {
  verbatim = verbatimBegin verbatimInnards+ verbatimEnd
  verbatimInnards =
    | verbatimBegin expr verbatimEnd -- switchGrammars
    | ~verbatimBegin ~verbatimEnd any -- flat
  expr = applySyntactic<Expression>
//}



//Tag {
  TagName = "‚ü®#" name "‚ü©"
  TagDefinition = "‚ü®#" name name+ "‚ü©"
  Tag = 
    | "‚ü®#" name expr "‚ü©"
    | "‚ü®#" name name "‚ü©"
//}

//Dtype {
  DtypeName = "‚ü®" name "‚ü©"
  DtypeDefinition = "‚ü®#" name name+ "‚ü©"
  Dtype =
    | "‚ü®#" name Expression "‚ü©"
    | "‚ü®#" name name "‚ü©"
//}

//List {
  listEnd = "]"
  dtypeListBegin = "[‚ü®"
  tagListBegin = "[‚ü®#"
  genericListBegin = "["
  DtypeList = dtypeListBegin Expression* listEnd
  TagList = tagListBegin Expression* listEnd
  GenericList = genericListBegin Expression* listEnd
//}

//Name {
  name =
    | compoundName -- compoundName
    | self -- self
    | phi -- null
    | basicName -- basicName

  compoundName = "‚ù≤" (~nameBracket any)* "‚ù≥"
  basicName = nameFirst nameRest*
  nonSpecialName = ~self ~keyword name
  
  nameFirst = letter | "_"
  nameRest = alnum | "_"

//}

//Operator {
  StateQueryExpression = query self StateQueryClause+
  DtypeQueryExpression = query DtypeName DtypeQueryClause+
  TagQueryExpression = query TagName TagQueryClause+
  ForallExpression = forAll Expression temporaryName Block

StateQueryClause = query self "{" Expression Expression "}"
DtypeQueryClause = query DtypeName "{" Expression Expression "}"
TagQueryClause = query TagName "{" Expression Expression "}"

  StateUpdateExpression = Expression updateState self 
//}

//ParameterList {
  FormalParameterList = "(" pname* ")"
  ActualParameterList = "(" Expression* ")"
  pname = parameterPrefix name
//}

// StateList {
  PossibleStates = "{" sname+ "}"
  sname = statePrefix name
//}

//Block {
  Block = "{" Expression* "}"
//}

//Synonym {
  SynonymScopedBlock = synonym name defineop Block
//}
  

}
